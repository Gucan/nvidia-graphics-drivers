From dc351887a5ce3c4372de453f3f78ab8698036e3c Mon Sep 17 00:00:00 2001
From: Alberto Milone <alberto.milone@canonical.com>
Date: Thu, 19 May 2016 16:46:07 +0200
Subject: [PATCH 1/1] Add support for Linux 4.6

Deal with the now dropped put_page() and with get_user_pages()
taking fewer arguments.
---
 nvidia-uvm/uvm8_tools.c            |  4 ++++
 nvidia-uvm/uvm_full_pagetbl_mgmt.c |  8 ++++++++
 nvidia/os-mlock.c                  | 13 +++++++++++++
 3 files changed, 25 insertions(+)

diff --git a/nvidia-uvm/uvm8_tools.c b/nvidia-uvm/uvm8_tools.c
index dff21a1..b124d89 100644
--- a/nvidia-uvm/uvm8_tools.c
+++ b/nvidia-uvm/uvm8_tools.c
@@ -157,7 +157,11 @@ static NV_STATUS map_user_pages(NvU64 user_va, NvU64 size, void **addr, struct p
     }
 
     down_read(&current->mm->mmap_sem);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
     ret = get_user_pages(current, current->mm, user_va, num_pages, 1, 0, *pages, NULL);
+#else
+    ret = get_user_pages(user_va, num_pages, 1, 0, *pages, NULL);
+#endif
     up_read(&current->mm->mmap_sem);
     if (ret != num_pages) {
         status = NV_ERR_INVALID_ARGUMENT;
diff --git a/nvidia-uvm/uvm_full_pagetbl_mgmt.c b/nvidia-uvm/uvm_full_pagetbl_mgmt.c
index 99f04a3..5b0fb71 100644
--- a/nvidia-uvm/uvm_full_pagetbl_mgmt.c
+++ b/nvidia-uvm/uvm_full_pagetbl_mgmt.c
@@ -2907,7 +2907,11 @@ NV_STATUS uvmfull_access_memory(UvmVaspace *vaspace, NvU64 userCopyBuffer, NvU64
 
         // get userPA for this range
         down_read(&current->mm->mmap_sem);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
         returnVal = get_user_pages(current, current->mm, (unsigned long)(UVM_ALIGN_ADDR(userCopyBuffer, PAGE_SIZE_4K)),
+#else
+        returnVal = get_user_pages((unsigned long)(UVM_ALIGN_ADDR(userCopyBuffer, PAGE_SIZE_4K)),
+#endif
             userPagesReq, 1, 0, tempUserPageArray, NULL);
         up_read(&current->mm->mmap_sem);
 
@@ -2937,7 +2941,11 @@ cleanup_vadesc:
                     set_page_dirty_lock(tempUserPageArray[i]);
 
             UVM_PANIC_ON(tempUserPageArray[i] == 0);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
             page_cache_release(tempUserPageArray[i]);
+#else
+            put_page(tempUserPageArray[i]);
+#endif
             tempUserPageArray[i] = 0;
         }
 
diff --git a/nvidia/os-mlock.c b/nvidia/os-mlock.c
index 9d8b495..a7d7b9a 100644
--- a/nvidia/os-mlock.c
+++ b/nvidia/os-mlock.c
@@ -116,7 +116,11 @@ NV_STATUS NV_API_CALL os_lock_user_pages(
     }
 
     down_read(&mm->mmap_sem);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
     ret = get_user_pages(current, mm, (unsigned long)address,
+#else
+    ret = get_user_pages((unsigned long)address,
+#endif
             page_count, write, force, user_pages, NULL);
     up_read(&mm->mmap_sem);
     pinned = ret;
@@ -129,7 +133,11 @@ NV_STATUS NV_API_CALL os_lock_user_pages(
     else if (pinned < page_count)
     {
         for (i = 0; i < pinned; i++)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
             page_cache_release(user_pages[i]);
+#else
+            put_page(user_pages[i]);
+#endif
         os_free_mem(user_pages);
         return NV_ERR_INVALID_ADDRESS;
     }
@@ -156,7 +164,12 @@ NV_STATUS NV_API_CALL os_unlock_user_pages(
     {
         if (write)
             set_page_dirty_lock(user_pages[i]);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
         page_cache_release(user_pages[i]);
+#else
+        put_page(user_pages[i]);
+#endif
+
     }
 
     os_free_mem(user_pages);
-- 
1.9.1

